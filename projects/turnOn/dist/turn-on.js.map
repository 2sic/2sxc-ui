{"version":3,"sources":["webpack://turn-on/./src/constants.ts","webpack://turn-on/./src/debug.ts","webpack://turn-on/./src/status/status.ts","webpack://turn-on/./src/status/status-summary.ts","webpack://turn-on/./src/conditions/condition-name.ts","webpack://turn-on/./src/conditions/condition-function.ts","webpack://turn-on/./src/conditions/condition-function-name.ts","webpack://turn-on/./src/conditions/condition-maker.ts","webpack://turn-on/./src/conditions/exists-progress.ts","webpack://turn-on/./src/configuration/configuration.ts","webpack://turn-on/./src/tags/config-tag.ts","webpack://turn-on/./src/turnOn/settings.ts","webpack://turn-on/./src/configuration/config-helper.ts","webpack://turn-on/./src/tags/config-tag-manager.ts","webpack://turn-on/./src/tags/config-to-turn-on.ts","webpack://turn-on/./src/tags/tag-loader.ts","webpack://turn-on/./src/watch-promise/condition-as-promise.ts","webpack://turn-on/./src/turnOn/turn-on.ts","webpack://turn-on/./src/watch-promise/promise-boolean-as-promise.ts","webpack://turn-on/./src/turnOn/turn-on-root.ts","webpack://turn-on/./src/index.ts","webpack://turn-on/webpack/bootstrap","webpack://turn-on/webpack/runtime/define property getters","webpack://turn-on/webpack/runtime/hasOwnProperty shorthand","webpack://turn-on/webpack/startup"],"names":["attrConfig","attrSkip","windowName","logPrefix","log","message","obj1","obj2","window","debugTurnOn","console","type","ready","name","result","attempts","details","Array","isArray","filter","stat","length","detectIfAllOk","Status","statusType","createNameCondition","key","exists","ExistsProgress","test","success","matchedKey","createFnCondition","fn","toString","substr","namedFnType","make","condition","endsWith","fnCondition","nameCondition","substring","statusOfName","createFunctionNameCondition","parts","partsFound","split","current","match","i","part","ProgressError","tag","config","turnOn","this","syncDom","getAttribute","setAttribute","currentSerialized","JSON","stringify","progress","prog","error","LogError","LogDebug","FailReject","DefaultName","interval","failure","createError","await","debug","run","load","value","pretyped","configuration","parse","ex","ConfigHelper","stabilize","raw","startsWith","awaits","push","logMode","data","settings","Settings","root","tags","tryToLoadTag","node","attr","skip","add","ConfigTag","new","promise","then","checkExists","convertConfigToTurnOn","updateTags","forEach","t","attributes","childList","subtree","tagManager","scanExistingDom","document","querySelectorAll","activateObserver","MutationObserver","mutations","m","addedNodes","observe","documentElement","promiseType","checkFunction","lastStatus","innerCheck","check","asPromise","parent","checkCondition","resolve","reject","setTimeout","Promise","nameOrSettings","_conditionMaker","ConditionMaker","TurnOn","count","conditions","loadedCheckers","map","c","boolPromise","r","catch","reason","ConditionAsPromise","thisKs","instanceCount","all","list","summary","StatusSummary","logStatusList","id","statusList","ConfigTagManager","loader","TagLoader","TurnOnRoot","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call"],"mappings":"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","file":"turn-on.js","sourcesContent":["\r\nexport const attrConfig = 'turn-on';\r\nexport const attrSkip = 'turn-on-skip';\r\n\r\nexport const windowName = 'window';\r\n\r\nexport const logPrefix = 'turn-on: ';","\r\n// const debug = true;\r\n\r\nimport { logPrefix } from './constants';\r\n\r\nexport function log(message: string, obj1?: unknown, obj2?: unknown): void {\r\n  if(!window.debugTurnOn) return;\r\n  if(obj2) console.log(logPrefix + message, obj1, obj2);\r\n  else if(obj1)  console.log(logPrefix + message, obj1);\r\n  else console.log(logPrefix + message);\r\n}","\r\nconst nameNotDefined = 'not set';\r\n\r\nexport class Status {\r\n  constructor(\r\n    /** The status type, like window-key, function, summary etc. */\r\n    public type: string,\r\n\r\n    /** Status if the check has been successful */\r\n    public ready: boolean,\r\n\r\n    /** Status message if provided */\r\n    public message: string, \r\n    \r\n    /** name of this status, to better point to which rule failed */\r\n    public name: string = nameNotDefined,\r\n    \r\n    /** result of a check - in some cases needed for next steps */\r\n    public result?: unknown\r\n    ) {\r\n  }\r\n\r\n  /** Amount of attempts tried till this  */\r\n  attempts? = 0;\r\n\r\n}\r\n","import { Status } from '.';\r\n\r\n\r\nexport class StatusSummary extends Status {\r\n\r\n  constructor(details: Status[]) {\r\n    // no details provided, then assume ok\r\n    if (!details) details = [];\r\n\r\n    const ready = detectIfAllOk(details);\r\n\r\n    const message = details.length === 0\r\n      ? 'no conditions provided'\r\n      : ready\r\n        ? 'all ok'\r\n        : 'some conditions did not complete';\r\n    super('summary', ready, message, 'Summary');\r\n    this.details = details;\r\n  }\r\n\r\n  /** Details of each of the status received */\r\n  details: Status[]\r\n}\r\n\r\nfunction detectIfAllOk(details: Status[]) {\r\n  // some kind of error appeared, shouldn't be ok\r\n  if (!Array.isArray(details)) return false;\r\n\r\n  // count if all details have a ready-state\r\n  return (details.filter(stat => stat.ready).length == details.length)\r\n}","import { Condition, ExistsProgress } from '.';\r\nimport { Status, windowName } from '..';\r\n\r\nconst statusType = 'window-key';\r\n\r\n/**\r\n * Create a checker which verifies if a key or key-sequence on window exists\r\n */\r\nexport function createNameCondition(key: string): Condition {\r\n  // empty-ish strings - always say it's done\r\n  if (!key) return () => new Status(statusType, true, 'empty key', key);\r\n  if (key === windowName) return () => new Status(statusType, true, 'no keys except maybe windows found', key);\r\n\r\n  return () => {\r\n    const exists = ExistsProgress.test(key);\r\n    if(exists.success) return new Status(statusType, true, 'all keys matched', key, exists.result);\r\n    return new Status(statusType, false, `Not all keys matched yet. So far '${exists.matchedKey}' worked.`, key);\r\n  }\r\n}","import { Condition } from '.';\r\nimport { Status } from '..';\r\n\r\n/**\r\n * Create a condition based on a function which will be polled till it returns truthy\r\n */\r\nexport function createFnCondition(fn: () => boolean): Condition {\r\n  let name = fn.toString();\r\n  if (name && name.length > 25) name = name.substr(0, 25);\r\n  return () => { \r\n    return new Status('fn', fn(), '', name);\r\n  }\r\n}","import { Condition } from '.';\r\nimport { createNameCondition } from './condition-name';\r\nimport { createFnCondition } from './condition-function';\r\n\r\nconst namedFnType = 'named fn';\r\n\r\n/**\r\n * Create a condition which waits for a function to exist, and then polls it till the result is ok.\r\n */\r\nexport function createFunctionNameCondition(key: string): Condition {\r\n  if(!key.endsWith('()')) throw `Tried to create Function-Name condition but that requires it to end with (), got ${key}`;\r\n\r\n  const keyWithoutBrackets = key.substring(0, key.length - 2);\r\n  let fnCondition: Condition;\r\n  const nameCondition = createNameCondition(keyWithoutBrackets);\r\n  return () => {\r\n\r\n    // As long as the name doesn't exist, check that and return that status\r\n    // But only do this till we have the fnCondition once, then skip\r\n    if(!fnCondition) {\r\n      const statusOfName = nameCondition();\r\n      if(!statusOfName.ready) return { ...statusOfName, type: namedFnType} ;\r\n\r\n      // Check if we really got a function - if not, assume all is ok and don't try to call\r\n      if(typeof(statusOfName.result) !== 'function') return { ...statusOfName, type: namedFnType };\r\n      \r\n      // Create the function-condition to use from now on. \r\n      fnCondition = createFnCondition(statusOfName.result as () => boolean);\r\n    }\r\n\r\n    // once the name exists, try to get the function\r\n    return { ...fnCondition(), type: namedFnType };\r\n  }\r\n}","import { Condition, ConditionRaw, createFnCondition, createNameCondition } from '.';\r\nimport { createFunctionNameCondition } from './condition-function-name';\r\n\r\n/**\r\n * Internal class to generate is-it-ready checkers\r\n */\r\nexport class ConditionMaker {\r\n\r\n  /**\r\n   * Make a new condition checker\r\n   */\r\n  public make(condition: ConditionRaw): Condition {\r\n    if (typeof(condition) === 'function')\r\n      return createFnCondition(condition);\r\n    \r\n    if (typeof(condition) === 'string')\r\n      return condition.endsWith('()')\r\n        ? createFunctionNameCondition(condition)\r\n        : createNameCondition(condition);\r\n  }\r\n}","import { windowName } from '..';\r\n\r\nexport class ExistsProgress {\r\n  constructor(\r\n    public success: boolean,\r\n    public result: unknown,\r\n    public parts: number,\r\n    public partsFound: number,\r\n    public matchedKey?: string,\r\n  ) { }\r\n\r\n  static test(key: string): ExistsProgress {\r\n    if(!key) return new ExistsProgress(true, null, 0, 0);\r\n\r\n    const parts = key.split('.');\r\n    if(parts[0] !== windowName) throw `Key must start with '${windowName}.' but it's '${key}'`;\r\n\r\n    // Only contains window\r\n    if (parts.length == 1) return new ExistsProgress(true, null, 1, 1);\r\n\r\n    let current = window as any;\r\n    let match = windowName;\r\n    for (let i = 1; i < parts.length; i++) {\r\n      const part = parts[i];\r\n      current = current[part];\r\n      // found, so let's add to list of successful matches\r\n      match += '.' + part;\r\n\r\n      // if node not found, stop checking\r\n      if (!current) return new ExistsProgress(false, null, parts.length, i, match);\r\n    }\r\n    return new ExistsProgress(true, current, parts.length, parts.length);\r\n  }\r\n}","import { Settings } from '../turnOn/settings';\r\nexport const Progress1Loaded = '1-loaded';\r\nexport const Progress2Watching = '2-watching';\r\nexport const Progress3Running = '3-running';\r\nexport const Progress4Completed = '4-completed';\r\nexport const Progress9Cancelled = '9-cancelled';\r\nexport const ProgressError = '9-error';\r\n\r\nexport type TurnOnProgres = typeof Progress1Loaded | typeof Progress2Watching  | typeof Progress3Running | typeof Progress4Completed | typeof Progress9Cancelled | typeof ProgressError ;\r\n\r\nexport interface TurnOnConfiguration {\r\n  /** Things to wait for - names on window (or sub-objects) or functions on window or sub-objects */\r\n  await: string[];\r\n\r\n  /** Special flag to log everything that's happening for extensive debugging */\r\n  debug: boolean;\r\n\r\n  /**\r\n   * What to run when all awaits have succeeded. \r\n   * The system will also wait for this to exist before it runs it. \r\n   */\r\n  run: string;\r\n\r\n  /** Information how far processing of this configuration has commenced */\r\n  progress: TurnOnProgres;\r\n\r\n  /** Possible error information */\r\n  error?: string;\r\n\r\n  /** Optional data to give the function once it starts */\r\n  data?: unknown;\r\n\r\n  /** Settings used for this turn-on */\r\n  settings?: Settings\r\n}\r\n","import { TurnOnConfiguration, TurnOnProgres } from '../configuration';\r\nimport { attrConfig, attrSkip } from '..';\r\nimport { log } from '../debug';\r\nimport { TurnOn } from '../turnOn/turn-on';\r\nimport { ProgressError } from '../configuration/configuration';\r\n\r\n\r\nexport class ConfigTag {\r\n\r\n  constructor(\r\n    public tag: HTMLElement,\r\n    public config: TurnOnConfiguration,\r\n    public turnOn?: TurnOn\r\n  ) \r\n  { \r\n    this.syncDom();\r\n  }\r\n\r\n  syncDom(): void {\r\n    log('syncDom', this);\r\n    const tag = this.tag;\r\n    // set skip if missing and update json in html if not current\r\n    // Do these checks to avoid to many DOM changes\r\n    if(!tag.getAttribute(attrSkip)) tag.setAttribute(attrSkip, \"skip\");\r\n    const currentSerialized = JSON.stringify(this.config);\r\n    if(tag.getAttribute(attrConfig) !== currentSerialized)\r\n      tag.setAttribute(attrConfig, currentSerialized);\r\n  }\r\n\r\n  progress(prog: TurnOnProgres): void {\r\n    this.config.progress = prog;\r\n    this.syncDom();\r\n  }\r\n\r\n  error(message: string): void {\r\n    this.config.progress = ProgressError;\r\n    this.config.error = message;\r\n    this.syncDom();\r\n    throw this.config.error;\r\n  }\r\n}","\r\n// this must be a simple const, otherwise the anotation below with typeof won't work\r\n// https://stackoverflow.com/questions/56263200/how-to-define-string-literal-union-type-from-constants-in-typescript\r\nexport const LogError = 'error';\r\nexport const LogDebug = 'debug';\r\nexport const LogSilent = 'silent';\r\n\r\nexport const FailSilent = 'silent';\r\nexport const FailResolve = 'resolve';\r\nexport const FailReject = 'reject';\r\nexport const DefaultName = 'turnOn';\r\n\r\nexport type LogMode = typeof LogError | typeof LogDebug | typeof LogSilent;\r\n\r\nexport class Settings {\r\n  /** the polling interval - defaults to 100 */\r\n  interval = 100;\r\n\r\n  /** polling attempts, defaults to 100 */\r\n  attempts = 100;\r\n \r\n  /** What to log into the console */\r\n  log: LogMode = LogError;\r\n\r\n  /**\r\n   * Failure mode, if by timeout it's not successful\r\n   * - reject (default)= use promise reject (which will throw an error if not handled)\r\n   * - resolve = use promise resolve and give a status back which says it's not complete\r\n   * - silent = don't complete the promise\r\n   */\r\n  failure: typeof FailReject | typeof FailResolve | typeof FailSilent = FailReject;\r\n\r\n  /** The name of this turnOn - to better track issues */\r\n  name = DefaultName;\r\n}","import { Progress1Loaded, ProgressError, TurnOnConfiguration } from '.';\r\nimport { TurnOnConfigurationRaw } from '..';\r\nimport { LogMode, Settings, LogError, LogDebug } from '../turnOn/settings';\r\n\r\nexport class ConfigHelper {\r\n\r\n  /**\r\n   * Create a configuration object which just contains an error\r\n   */\r\n  static createError(message: string): TurnOnConfiguration {\r\n    const result: TurnOnConfiguration = {\r\n      await: [],\r\n      debug: false,\r\n      run: '',\r\n      progress: ProgressError,\r\n      error: message\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Load a configuration from a string usually from an Html attribute\r\n   */\r\n  static load(value: string): TurnOnConfiguration {\r\n    let pretyped: TurnOnConfigurationRaw;\r\n    try {\r\n      pretyped = JSON.parse(value);\r\n    }\r\n    catch (ex) {\r\n      return ConfigHelper.createError(`detected configuration but cannot parse to json.`);\r\n    }\r\n    let configuration: TurnOnConfiguration;\r\n    try {\r\n      configuration = ConfigHelper.stabilize(pretyped);\r\n    }\r\n    catch (ex) { \r\n      return ConfigHelper.createError(`Error loading configuration, reason unknown.`)\r\n    }\r\n  \r\n    return configuration;\r\n  }\r\n\r\n  /**\r\n   * Import a raw configuration and make sure it's fully compliant\r\n   */\r\n  private static stabilize(raw: TurnOnConfigurationRaw): TurnOnConfiguration {\r\n    if(!raw) return ConfigHelper.createError('No config data found to process');\r\n    if(!raw.run) return ConfigHelper.createError(`Config didn't contain 'run' - it's required.`);\r\n    if(!raw.run.startsWith('window')) return ConfigHelper.createError(`run command must start with 'window.' but is:` + raw.run);\r\n    if(!raw.run.endsWith('()')) return ConfigHelper.createError(`run must be a function name and end with () but it's:` + raw.run);\r\n  \r\n    const awaits = Array.isArray(raw.await) \r\n          ? raw.await\r\n          : raw.await \r\n            ? [raw.await]\r\n            : [];\r\n  \r\n    // also always await the run command, but without the () as it shouldn't be called to detect if it's ready    \r\n    awaits.push(raw.run.substring(0, raw.run.length-2));\r\n  \r\n    const logMode: LogMode = (raw?.debug ?? false) ? LogDebug : LogError;\r\n\r\n    const stable: TurnOnConfiguration = {\r\n      await: awaits,\r\n      debug: raw.debug ?? false,\r\n      run: raw.run,\r\n      progress: Progress1Loaded,\r\n      data: raw.data || { }, // give empty object so a developer can see this would exist as an option\r\n      settings: { ...new Settings(), log: logMode, ...raw.settings }\r\n    }\r\n    return stable;\r\n  }\r\n}","import { TurnOnConfiguration } from '../configuration';\r\nimport { attrConfig, attrSkip, log } from '..';\r\nimport { TurnOnRoot } from '../turnOn';\r\nimport { ConfigTag, convertConfigToTurnOn } from '.';\r\nimport { ConfigHelper, ProgressError } from '../configuration';\r\n\r\nexport class ConfigTagManager {\r\n  \r\n  public tags = new Array<ConfigTag>();\r\n\r\n  constructor(public root: TurnOnRoot) {\r\n    \r\n  }\r\n\r\n\r\n  tryToLoadTag(node: HTMLElement): void {\r\n    // Get config and skip if not relevant, or skip if already marked as in the queue\r\n    const attr = node?.getAttribute?.(attrConfig);\r\n    if(!attr) return;\r\n    const skip = node?.getAttribute?.(attrSkip);\r\n    log('skip', skip);\r\n    if(skip) return log('skip');\r\n\r\n    log('attr', attr);\r\n    const config = ConfigHelper.load(attr);\r\n    if(config.progress === ProgressError) {\r\n      console.error(config.error, node, attr);\r\n      return;\r\n    }\r\n    log('stable config')\r\n    this.add(node, config);\r\n  }\r\n  \r\n  /**\r\n   * \r\n   */\r\n  add(node: HTMLElement, config: TurnOnConfiguration): void {\r\n    log('add', node, config);\r\n    const tag = new ConfigTag(node, config);\r\n    this.tags.push(tag);\r\n    convertConfigToTurnOn(this.root, tag);\r\n  }\r\n\r\n  updateTags(): void {\r\n    log(`updateTags: ${this.tags.length}`);\r\n    this.tags.forEach((t) => t.syncDom())\r\n  }\r\n\r\n}","import { ConfigTag } from '.';\r\nimport { log, Status } from '..';\r\nimport { Progress2Watching, Progress3Running, Progress4Completed } from '../configuration';\r\nimport { TurnOnRoot } from '../turnOn';\r\nimport { ExistsProgress } from '../conditions/exists-progress';\r\n\r\n/**\r\n * \r\n */\r\nexport function convertConfigToTurnOn(root: TurnOnRoot, tag: ConfigTag): Promise<Status> {\r\n  const config = tag.config;\r\n  log('convert to turnon');\r\n  const turnOn = root.new(config.settings);\r\n  config.settings = turnOn.settings;\r\n  const promise = turnOn.await(config.await);\r\n  tag.progress(Progress2Watching);\r\n\r\n  promise.then(() => {\r\n    const run = config.run;\r\n    log('turn on success - will try to run ' + run);\r\n    tag.progress(Progress3Running);\r\n    if(!run.endsWith('()')) {\r\n      tag.error(`run should end with () but doesn't - can't continue`);\r\n      return;\r\n    }\r\n\r\n    const checkExists = ExistsProgress.test(run.substr(0, run.length - 2));\r\n\r\n    // if node not found, stop checking\r\n    if (!checkExists.success) {\r\n      tag.error(`Tried to find object parts for ${checkExists.matchedKey} but didn't get anything.`);\r\n      return;\r\n    }\r\n    if(typeof(checkExists.result) !== 'function') {\r\n      tag.error(`Got ${checkExists.partsFound} but it's not a function`);\r\n      return;\r\n    }\r\n\r\n    // now run it!\r\n    const fn = checkExists.result as (x: unknown) => unknown;\r\n    fn({ ...config, tag: tag });\r\n    tag.progress(Progress4Completed);\r\n  });\r\n  return promise;\r\n}\r\n\r\nconsole.log('hello!');","import { ConfigTagManager, log } from '..';\r\n\r\n/**\r\n * Options for the observer (which mutations to observe)\r\n */\r\nconst config : MutationObserverInit = { \r\n  attributes: false, \r\n  childList: true, \r\n  subtree: true \r\n};\r\n\r\n/**\r\n * In charge of loading all turn-on tags from the DOM, both at first load as well as on DOM changes\r\n */\r\nexport class TagLoader {\r\n\r\n  constructor(public tagManager: ConfigTagManager) {\r\n    this.scanExistingDom();\r\n  }\r\n\r\n  public scanExistingDom(): void {\r\n    log('scanExistingDom');\r\n    const tags = document.querySelectorAll(`[turn-on]`);\r\n    log('tags:', tags);\r\n    tags.forEach((t: HTMLElement) => this.tagManager.tryToLoadTag(t));\r\n  }\r\n\r\n  public activateObserver(): void {\r\n    log('load');\r\n  \r\n    const observer = new MutationObserver((mutations) => {\r\n      log('turnOn mutation');\r\n      // Loop through each changed item, check if it's something we want to initialize\r\n      mutations.forEach((m) => {\r\n        // Nodes added - let's check if it is a turn-on\r\n        if(m.type != 'childList') return;\r\n        log('hit children');\r\n\r\n        m.addedNodes.forEach((node: HTMLElement) => this.tagManager.tryToLoadTag(node));\r\n      });\r\n    });\r\n  \r\n    // observe document for tags which include this. ATM don't observe header\r\n    observer.observe(document.documentElement, config);\r\n  }\r\n\r\n}\r\n","import { Status } from '..';\r\nimport { Settings } from '../turnOn';\r\n\r\nconst promiseType = 'promise';\r\nexport class ConditionAsPromise {\r\n\r\n  public settings: Settings;\r\n\r\n  constructor(checkFunction: () => Status, settings: Settings) {\r\n    this.innerCheck = checkFunction;\r\n    this.settings = settings;\r\n  }\r\n\r\n  public lastStatus: Status = new Status(promiseType, false, 'condition not checked yet');\r\n  public attempts = 0;\r\n\r\n  /**\r\n   * Dummy innerCheck function - should be replaced in the constructor\r\n   */\r\n  public innerCheck(): Status { return new Status(promiseType, true, 'no condition defined') }\r\n\r\n  public check(): Status {\r\n    if (this.lastStatus.ready === true) return this.lastStatus;\r\n\r\n    // check and store\r\n    this.lastStatus = this.innerCheck();\r\n\r\n    return this.lastStatus;\r\n  }\r\n\r\n  public asPromise(): Promise<Status> {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const parent = this;\r\n    const checkCondition = function(resolve: (value: Status) => void, reject: (reason: unknown | null) => void) {\r\n      // If the condition is met, we're done! \r\n      const result = parent.check();\r\n\r\n      // if all is ok (true) then complete the promise\r\n      if(result.ready === true) {\r\n        resolve( { ...result, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      if(parent.attempts++ >= parent.settings.attempts) {\r\n        resolve({ ...result, message: 'tried up to max attempts: ' + result.message, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      // If the condition isn't met but the timeout hasn't elapsed, go again\r\n      setTimeout(checkCondition, parent.settings.interval, resolve, reject);\r\n    };\r\n\r\n    return new Promise(checkCondition)\r\n  }\r\n}\r\n","import { Settings, LogDebug, LogSilent } from '.';\r\nimport { DefaultName, FailReject, FailResolve, FailSilent } from './settings';\r\nimport { promiseBoolToStatus } from '../watch-promise/promise-boolean-as-promise';\r\nimport { ConditionAsPromise, ConditionMaker, ConditionRaw, Status, StatusSummary } from '..';\r\nimport { logPrefix } from '../constants';\r\n\r\nexport class TurnOn {\r\n\r\n  /** The settings applied to this turnOn */\r\n  public settings = new Settings();\r\n\r\n  /** Constructor with optional settings */\r\n  constructor(nameOrSettings?: Partial<Settings> | string) {\r\n    if (typeof nameOrSettings === 'string') {\r\n      nameOrSettings = {\r\n        name: nameOrSettings\r\n      };\r\n    }\r\n\r\n    if (nameOrSettings)\r\n      this.settings = { ...this.settings, ...nameOrSettings };\r\n\r\n    TurnOn.count++;\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly usefuly in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n\r\n  public await(conditions: ConditionRaw | ConditionRaw[]): Promise<Status> {\r\n\r\n    // re-wrap to ensure we always work with an array\r\n    const conditionsArray = (Array.isArray(conditions)) ? conditions : [conditions];\r\n\r\n    // convert conditions to promises\r\n    const loadedCheckers = conditionsArray.map(c => {\r\n      // do this for non-promise conditions\r\n      if (Promise.resolve(c as unknown) === c) {\r\n        return promiseBoolToStatus(c);\r\n      } else {\r\n        const condition = this._conditionMaker.make(c);\r\n        const loaded = new ConditionAsPromise(condition, this.settings);\r\n        return loaded.asPromise();  \r\n      }\r\n    });\r\n\r\n    // keep the current turnOn-object for reference in methods\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const thisKs = this;\r\n\r\n    // keep count as it was on start, to ensure it doesn't change any more till we log the error\r\n    const instanceCount = TurnOn.count;\r\n\r\n    const flattened = new Promise<StatusSummary>((resolve, reject) => { \r\n      // return a single promise for all inner promises which either fail or resolve\r\n      Promise.all(loadedCheckers).then(list => {\r\n\r\n        // get summary of all details infos\r\n        const summary = new StatusSummary(list);\r\n\r\n        // by default, log details about what failed\r\n        if (window.debugTurnOn || thisKs.settings.log === LogDebug || (!summary.ready && thisKs.settings.log !== LogSilent))\r\n          thisKs.logStatusList(summary.ready, instanceCount, thisKs.settings, list);\r\n\r\n        // if all is ok, resolve now\r\n        if (summary.ready === true) {\r\n          resolve(new StatusSummary(list));\r\n          return;\r\n        }\r\n\r\n        // depending on the need, either reject/error (default) or resolve with false\r\n        switch (thisKs.settings.failure){\r\n          case FailReject: reject(summary); break;\r\n          case FailResolve: resolve(summary); break;\r\n          case FailSilent: return;\r\n        }\r\n      })\r\n    });\r\n      \r\n    return flattened;\r\n  }\r\n\r\n  public logStatusList(success: boolean, id: number, settings: Settings, statusList: Status[]): void {\r\n    console.log(logPrefix + `#${id} `\r\n    + (settings.name !== DefaultName ? `\"${settings.name}\" ` : '')\r\n    + (success ? 'success!' : `couldn't complete because some conditions were not met. See details: `),\r\n     statusList);\r\n  }\r\n\r\n  private _conditionMaker = new ConditionMaker();\r\n\r\n  private static count = 0;\r\n}","import { Status } from '..';\r\n\r\nexport function promiseBoolToStatus(boolPromise: Promise<boolean>): Promise<Status> {\r\n  return new Promise<Status>((resolve, reject) => {\r\n    boolPromise\r\n      .then(r => {\r\n        const result = r !== false;\r\n        resolve(new Status('bool-promise', result, 'from promise'));\r\n    })\r\n      .catch(reason => reject(reason));\r\n  });\r\n}\r\n","import { Settings, TurnOn } from '.';\r\nimport { TagLoader } from '..';\r\nimport { ConfigTagManager } from '../tags/config-tag-manager';\r\n\r\nexport class TurnOnRoot {\r\n  \r\n  tagManager: ConfigTagManager;\r\n\r\n  loader: TagLoader;\r\n\r\n  constructor()\r\n  {\r\n    this.tagManager = new ConfigTagManager(this);\r\n    this.loader = new TagLoader(this.tagManager);\r\n    console.log('turnOn v0.1 active - it will help boot scripts when ready - set window.debugTurnOn = true for debugging')\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly usefuly in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n}","\r\nexport * from './constants';\r\nexport * from './debug';\r\n\r\nexport * from './status';\r\nexport * from './conditions';\r\nexport * from './tags';\r\nexport * from './watch-promise';\r\n\r\nimport { TurnOnRoot } from './turnOn';\r\nexport * from './window';\r\n\r\nif (!window.turnOn) window.turnOn = new TurnOnRoot();\r\nconst turnOn = window.turnOn as TurnOnRoot;\r\n\r\nturnOn.loader.activateObserver();\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// startup\n// Load entry module\n__webpack_require__(309);\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}